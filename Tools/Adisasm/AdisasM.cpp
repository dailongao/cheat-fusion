////////////////////////////////////////////////////////////
// if this works, it was made by Antiloop (aka Adriaan Moors)
// it it doesn't i dunno who made it ;-)
// mail me at: adriaan@myself.com, UIN=2622257 (ICQ)

// FEEL FREE TO IMPROVE THIS CODE IN WHATEVER WAY YOU SEE FIT, 
// BUT IF YOU DO, LET ME KNOW (YOU CAN ADD YOUR NAME TO THE HISTORY LIST)
// and please leave this header intact
// I hope this will become the best disassembler available and I'm counting on your help!

// COMPILER: VC 5, with STL

//////////////////////////////////////////////////////////////
// HISTORY: current version 0.2b: now beta cuz i've tested it (a bit.. ;) )
// * Antiloop, i started the damned thing in February 1998 (ver 0.1b)
// * Antiloop, came up with a new scheme that should detect code better,
//   assumes the prog is procedure-based (ie. compiled language) 
//   although it should work ok with hand crafted assembly that doesn't (?) use functions,
//   prolly should add a switch to disable pseudo-'intelligent' processing (-u) (alpha, reworked, not finished)
// * July 18th, first public release.. hope it all kind of works :O) (beta, tested)

//////////////////////////////////////////////////////////////
// TODO: <DONE> the data detection system needs to be rewritten, it should work with a procedural based context system or sth like that
//         in other words: see if it is reached (between proc entry and jr ra), and if it isn't, treat as code
// this is a bit dodgy, but most code is generated by a compiler neway, and if it isn't, it prolly obeys to the rules (like end your proc with a jr ra)
// !!POSSIBLE BUG!! i've seen code that copies ra in some temp reg and then jumps back using that reg, and i don't feel like adding detection for that... volunteers ;) ?


//							* implement string extraction.. bah any volunteers? ;)
//       * improve unreachable code-detection scheme, this should also take relative(conditional)
//         branches in to consideration, because some chunk of code could jump over its jr ra 
//         or other terminating instruction (ie. unconditional jump)
//       * finish syscall wrapper detection
//       * add support for synthetic instructions
//       * add support for re-assembly
//       * find out the correct gte mnemonics
//      (* later: maybe even make it output some sort of pseudo code with if's and stuff, this should be possible for code 
//         that is generated by a (c) compiler)

// KNOWN BUGS (but too lazy to fix)
//       * the code detection scheme has a bit of an unwanted feature, 
//         namely it has no way of telling if a jump is actually data so it marks the target as code, 
//         although it is really data

///////////////////////////////////////////////////////////////
// NOTE: I know this proggy isn't fast... it isn't meant to be. i'm not going to spend time optimizing it
//       because that'll prolly give more bugs... :)
//       Just to make this clear... stuff is considered 'data' if it's not "properly" terminated.. use -u to avoid this



// <<<<<<<<<<<<<<<<<<<<<<<<-°¨ THANX and HAPPY CODING (or reversing) :O) _..->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> //



#include "precompiled.h"
#pragma hdrstop( "precompiled.h" )

using namespace std;

#include "AdisasM.h"
#include "mipscrap.h"

char disasmtemp[128];
char disasmtemp2[40];
void word2String(word d, char* s, char alt='.');
bool isValidAddress(word addr);
/*
extern char sysCalls[3][256][256]; // TODO

#include "syscallnames.inc"
*/
#include "strings.inc"

bool CPsxExe::optVerbose=false;
bool CPsxExe::optForceBin=false;
bool CPsxExe::optForceMachCode=false;
word CPsxExe::optLoadAddress=0;
word CPsxExe::optCodeLength=0;
word CPsxExe::optJumpAddress=0;
bool CPsxExe::optDumbString=false;
bool CPsxExe::optConsiderUnreachableCode=false;

CPsxExe::CPsxExe()
{
	lines=NULL;
}


bool CPsxExe::doCmdLine(int argc, char* argv[])
{		
	if(argc<2)
	{
		printf("Usage: %s exefile outfile [symfile] [-v] [-b <loadaddress> <entrypoint> [<codelength>]] [-c] [-s] [-u] [-h]\n",argv[0]);
		printf("\t <xxx> means that parameter in plain hex, you know, like 80010000\n");
		return false;
	}
	else if(argc>3) // options
	{
  for(int i=3;i<argc;i++)
		{
			if(*argv[i]=='-')
			{
				switch(tolower(*(argv[i]+1)))
				{
				case 'v':
					optVerbose=true;
					break;
				case 'b':
					optForceBin=true;
					if(argc-(++i)>=2) // we need at least two extra params
					{
						sscanf(argv[i++],"%x",&optLoadAddress);
						sscanf(argv[i++],"%x",&optJumpAddress);
						if(i<argc&&*argv[i]!='-')
							sscanf(argv[i],"%x",&optCodeLength);
					}
					
					i--; // too greedy above..

					break;
				case 'c':
					optForceMachCode=true;
					break;
				case 's':
					optDumbString=true;
					break;
				case 'u':
					optConsiderUnreachableCode=true;
					break;
				case 'h':
				default:
					printf("Usage: %s exefile outfile [symfile] [-v] [-b <loadaddress> <entrypoint> [<codelength>]] [-c] [-s] [-u] [-h]\n",argv[0]);
					printf("\t -v\tTurns verbose mode on\n\t -b\tForces me to open any file as pure binary, ie. no header\n\t -c\tTurns \"include code word\"-mode on.. go figure :-)\n\t -h\tONLY use when feeling lame. :-p\n\t -s\tTurns \"dumb string processing\"-mode on.. tsss... then this little proggy doesn't try to be smart ;-)\t -u\tAlso consider (seemingly) unreachable code.\n");
				}
			}
		}	 
		
		if(*argv[3]=='-') // no symtbl
			argc=3; //handle as if it was invoked w/o params nor symtbl
		else
			argc=4; //handle as if it was invoked w/o params w/ symtbl
	}
	
	if(argc==3)
	{
		loadExe(argv[1]);
		disassemble(argv[2]);
	}
	else
	{
		loadSymTbl(argv[3]);
		loadExe(argv[1]);
		disassemble(argv[2]);
	}
	
	return true;
}

CPsxExe::~CPsxExe()
{
	delete [] lines; 
}


void CPsxExe::loadSymTbl(char* name)
{
	char buff[10];
	FILE* f=fopen(name,"rt");

	fgets(buff,8,f);

	buff[3]=0;

	if(strcmp(buff,"MND")==0)
	{
		if(optVerbose)
			printf("PSYQ SYMBOL TABLE\n");
		fclose(f);
		f=fopen(name,"rb");
		fseek(f,8,SEEK_SET);
		syms.psyLoad(f);
	}
	
	if(f==NULL)
	{
		perror("opening symtbl");
		throw "error opening symbol table!";
	}

	fseek(f,0,SEEK_SET);
	
	syms.load(f);
}

void CPsxExe::loadExe(char* name)
{
	CPsxHeader Header;
	word* code;
	FILE* f=fopen(name,"rb");
	
	if(f==NULL)
		throw "error opening exe!";

	fseek(f,0,SEEK_SET);
	
	if(fread(&Header,1,2048,f)==2048 && !optForceBin && strcmp(Header.ID,"PS-X EXE")==0)
	{// ordinary exe
		if(optVerbose)
			printf("loadExe:\n id: %s\npad1: %s\nja: %x\npad2: %s\nla: %x\ntl: %x\npad3: %s\nsa: %x\npad4: %s\nterr: %c\npad5: %s\n",
											Header.ID,Header.Pad1,Header.JumpAddress,Header.Pad2,Header.LoadAddress,
											Header.TextLength,Header.Pad3,Header.StackAddress,Header.Pad4,Header.Territory,Header.Pad5);
											
		loadAddress=Header.LoadAddress;
		codeLength=Header.TextLength;
		entryPoint=Header.JumpAddress;

		word l=codeLength>>2;

		code=new word[l];

		if(fread(code,4,l,f)!=l)
		{
			delete [] code;
			fclose(f);
			throw "error reading exe!";
		}
		
		loadLines((word*)code);
		
		delete [] code;
		fclose(f);		
		return;
	}

	fseek(f,0,SEEK_SET);

	if(optForceBin) // then addies r set in cmd line
	{
		loadAddress=optLoadAddress;
		
		if(optCodeLength>0)
			codeLength=optCodeLength;
		else
		{
			fseek(f,0,SEEK_END);
			codeLength=ftell(f);
			fseek(f,0,SEEK_SET);
		}

		entryPoint=optJumpAddress;
	}
	else // take an educated guess..
	{
		loadAddress=entryPoint=0x80010000;
		fseek(f,0,SEEK_END);
		codeLength=ftell(f);
		fseek(f,0,SEEK_SET);
	}

	word l=codeLength>>2;

	code=new word[l];

	if(fread(code,4,l,f)!=l)
	{
		delete [] code;
		fclose(f);
		throw "error reading exe!";
	}

	loadLines((word*)code);

	delete [] code;

	fclose(f);
}



void CPsxExe::loadLines(word* code)
{
	ubyte op;
	bool prevWasBranch=false;
	word d;
	char tmp[81];
	string sym;
	sword codeStart; // 0 if data
	word i;
	word target; // address

	lines=new CCodeLine[codeLength];

	syms.markCode(this);

// PASS 1: scan for J(Al)'s 
 for(i=0;i<(codeLength>>2);i++)
	{
		lines[i].instruction=d=code[i];

		if(!isValidInstruction(d, (i<<2)+loadAddress))
			continue;
		
		op=DECODE_OP(d);

		if(d==I_JRRA) 
		{
			if(isValidInstruction(code[++i], (i<<2)+loadAddress))
				lines[i].flag=IF_CODE|IFC_PROC|IFP_END; // mark delay slot as end
			
			continue;
		}
		else if(op==opJ||(op==opSpecial&&DECODE_FUNC(d)==spJR))
		{
			if(isValidInstruction(code[++i], (i<<2)+loadAddress))
				lines[i].flag=IF_CODE|IFC_TERM; // mark delay slot as end
			
			continue;
		}
		
		if(op==opJ||op==opJAl)
		{
			//#define DECODE_INDEX(d,pc)  ((d&0x3ffffff)<<2|((pc+4)&0xf0000000))
			target=d&0x3ffffff;
			lines[i].flag=IF_CODE; // even if the target is invalid, this should be considered legit, cuz it can be a jump to libps for example
	
			if((target-loadAddress)<codeLength&&isValidInstruction(code[target], (target<<2)+loadAddress))
			{
				lines[target].flag=IF_CODE;
				
				if(op==opJAl)
					lines[target].flag|=IFC_PROC|IFP_BEGIN;
				else
					lines[target].flag|=IFC_LABEL;
			}			
		}
	}

	syms.addSym(entryPoint,"Entry",ST_PROC_EP);
	lines[(entryPoint-loadAddress)>>2].flag=IF_CODE|IFC_PROC|IFP_BEGIN;

// PASS 2: scan for continuous stretches of code, aka procedures, functions or subs
	codeStart=-1;

	for(i=0;i<(codeLength>>2);i++)
	{
		lines[i].instruction=d=code[i];

		if(!isValidInstruction(d, (i<<2)+loadAddress))
		{
			codeStart=-1;
			continue;
		}
		
		if(codeStart<0)
		{
			codeStart=i;
		}
		else	if(lines[i].flag&IFP_END) // delay slot of jr ra
		{
			for(int j=codeStart;j<=i;j++) // mark this entire stretch as code
			{
				lines[j].flag|=IF_CODE|IFC_PROC;
			}
			
			codeStart=-1;
		}
		else	if(lines[i].flag&IFC_TERM) // terminator
		{
			for(int j=codeStart;j<=i;j++) // mark this entire stretch as code
			{
				lines[j].flag|=IF_CODE;
			}
			
			codeStart=-1;
		}
		
		if(optConsiderUnreachableCode)
			lines[i].flag|=IF_CODE;
	}

// PASS 3: generate symbols (later also synthetic instructions here?)

	for(i=0;i<(codeLength>>2);i++)
	{
		if(!(lines[i].flag&IF_CODE))
			continue;

		d=code[i];
	 op=DECODE_OP(d);
	
	 if(op>=opRegImm&&op<=opBgtz) // if it is a branch and the target is fixed
		{
			lines[i].flag|=IFC_BRANCH;
			
			if(op>=opBeq||op==opRegImm) // relative branches
			{
				//#define DECODE_OFFSET(d,pc) (((signed short)(d&0x0000ffff)<<2)+pc+4)
				//target=((shword)d)+i+1;
				target=DECODE_OFFSET(d,(i<<2)+loadAddress);
				
				if((i<<2)+loadAddress-target<400) // loop of max 100 instructions
				{
					lines[i+1].flag|=IFC_LOOP|IFL_END;
					lines[(target-loadAddress)>>2].flag|=IFC_LOOP|IFL_BEGIN;
 
					for(int j=(target-loadAddress)>>2;j<=i;j++) // <=: include delayslot
						lines[j].flag|=IFC_LOOP;
				}
			}
			else // absolute branches: J(Al)
			{
				//#define DECODE_INDEX(d,pc)  ((d&0x3ffffff)<<2|((pc+4)&0xf0000000))
			 //target=d&0x3ffffff;
				target=DECODE_INDEX(d,(i<<2)+loadAddress);
			}

			if(target-loadAddress>codeLength)
				continue;
	
			lines[(target-loadAddress)>>2].flag|=IFC_LABEL;

			crossRef.addRef(target,(i<<2)+loadAddress);
					
			if(!syms.lookup(target,sym)) // generate a symbol
			{
				if(op==opJAl)
				{
/* 					word rad=target;

					if( rad+2 < codeLength) // if this is a syscall wrapper TODO
					{
						// addiu	t2, zero, xx
						// jr	t2 
						// addiu	t1, zero, yy

						word instr=lines[rad].instruction;

						if(DECODE_OP(instr)==opAddIU && DECODE_RS(instr)==regZero && DECODE_RT(instr)==regT2)
						{
							uhword syscall=DECODE_IMMED(instr);
							syscall=(syscall<<1)>>5-2; // a0 --> 0, b0 --> 1, c0 --> 2
									
							if(syscall<3)
							{
								instr=lines[rad+1].instruction;
								
								if(DECODE_OP(instr)==0 && DECODE_FUNC(instr)==spJR && DECODE_RS(instr)==regT2)
								{							
									instr=lines[rad+2].instruction;
									
									if(DECODE_OP(instr)==opAddIU && DECODE_RS(instr)==regZero && DECODE_RT(instr)==regT1&&DECODE_IMMED(instr)<=255)
									{
										syms.addSym(target,sysCalls[syscall][DECODE_IMMED(instr)],ST_PROC_EP); // TODO: prefix with __ to denote "wrapperness" :)
										continue;
									}
								}
							}
						}
					} */
		
					ubyte pref=target>>28;
						
					if(pref==0xb) // bios
					{
						sprintf(tmp,"bfunc%04x",target&0x000fffff);
					}
					else
						sprintf(tmp,"func%04x",target&0x0fffffff);

					syms.addSym(target,tmp,ST_PROC_EP);
					//printf("%s\n",tmp);
				}
				else if(lines[i].flag&(IFC_LOOP|IFL_BEGIN))
				{
					ubyte pref=target>>28;
					
					if(pref==0xb) // bios
					{
						sprintf(tmp,"bloop%04x",target&0x000fffff);
					}
					else
						sprintf(tmp,"loop%04x",target&0x0fffffff);

					syms.addSym(target,tmp,ST_LABEL);
				}
				else
				{
					ubyte pref=target>>28;
					
					if(pref==0xb) // bios
					{
						sprintf(tmp,"bL%04x", target&0x000fffff);
					}
					else
						sprintf(tmp,"L%04x", target&0x0fffffff);
					
					syms.addSym(target,tmp,ST_LABEL);
				}
			}
		}
		else if(op==opSpecial&&(DECODE_FUNC(d)==spJR||DECODE_FUNC(d)==spJAlR)) // branch, but target depends
		{
			lines[i].flag|=IFC_BRANCH|IFB_VAR;
			prevWasBranch=true;
		}
	}

	// PASS 4: TODO: string extraction... 
}



// lui	r, x
// addu	r, r, s
// memxs	*, y(r)
// -> unkxxxxyyyy[s] ; ( <memtype> r=xxxx0000+s )

// lui	r, x
// addiu	r, r, y
// addu	r, r, s
// memxs	*, z(r)
// -> unkxxxxyyyy[s+z] ; ( <memtype> r=xxxxyyyy+s )

// lui	r, x
// memxs	*, y(r)
// -> (<memtype>)(unkxxxxyyyy) ; r=xxxx0000


// lui	r, x
// addu	r, r, s
// -> r=xxxx0000 + s

// lui	r, x
// ori	r, r, y
// -> r=xxxxyyyy

// lui	r, x
// -> r=xxxx0000

// lui	r, x
// branch	s, r, loc
// -> if(s <branchtype> r)
// ->		goto loc;


// addiu	r, zero, x
// -> r=x

// addiu	r, zero, x
// branch	s, r, loc
// -> if(s <branchtype> x)
// ->		goto loc;

void CPsxExe::disassemble(char *name, word from, word to) // from and to must be absolute addresses
{
	if(lines==NULL)
		throw "load the file into memory prior to trying to disassembling it!";

	if(from>=to||(from-loadAddress)<0||(to-loadAddress)<0)
		throw "invalid region specified in disassemble!";

	char temp[256];
	char line[400];
	word d;
	uhword f;
	ubyte startad=0xff; // start of data in look ahead
	string sym;
 bool addData=false;
	bool assumeData=true;

	FILE* file=fopen(name,"w+t");

	for(word i=(from-loadAddress)>>2;i<(to-loadAddress)>>2;i++)
	{
		d=lines[i].instruction;
		f=lines[i].flag;

		if(syms.lookup((i<<2)+loadAddress,sym))
		{
			sprintf(line,"\n%08X\t%s:\n",(i<<2)+loadAddress,sym.data());
			fputs(line,file);
		}

			// code
		if(f&IF_CODE)
		{
			if( (f&IFC_BRANCH) )
			{
				ubyte op=DECODE_OP(d);
				word target;
				
				if(op>=opBeq||op==opRegImm) // relative branches
				{
					target=DECODE_OFFSET(d,(i<<2)+loadAddress);
				}
				else // j(al)
				{
					target=DECODE_INDEX(d,(i<<2)+loadAddress);
				}
				
				string sym;

				if(syms.lookup(target,sym))
				{
					if(op==opRegImm)
					{
						sprintf(disasmtemp,"%-7s%s, %s ;(0x%x)",RITypeMnem[DECODE_RT(d)],CPURegStr[DECODE_RS(d)],sym.data(), target);
					}
					else
					{
						if(op<opBeq) // j(al)
						{
							sprintf(disasmtemp,"%-7s%s ;(0x%x)",op==opJ ? "j":"jal",sym.data(),target);
						}
						else if(op<opBlez) // bne/beq
						{
							sprintf(disasmtemp,"%-7s%s, %s, %s ;(0x%x)",ITypeMnem[op],CPURegStr[DECODE_RS(d)],CPURegStr[DECODE_RT(d)],sym.data(),target); 
						}
						else // blez/bgtz
						{
							sprintf(disasmtemp,"%-7s%s, %s ;(0x%x)",ITypeMnem[op],CPURegStr[DECODE_RS(d)],sym.data(),target); 
						}
					}
					
					if(optForceMachCode)
					{
						fprintf(file, "%08X\t",d);
					} 

					//fputs(disasmtemp,file);
					fprintf(file, "%08X\t\t%s", (i<<2)+loadAddress, disasmtemp);
					
					fputc('\n',file);
					
					if((f&IFC_TERM)||(f&IFP_END))
						fputc('\n',file);

					continue;
				}	
			} // branch with symbol

			decodeInstruction(d,(i<<2)+loadAddress);
			
			if(optForceMachCode)
			{
				fprintf(file, "%08X\t",d);
			} 			
			
			//fputs(disasmtemp,file);
			fprintf(file, "%08X\t\t%s", (i<<2)+loadAddress, disasmtemp);
			
			fputc('\n',file);
			
			if((f&IFC_TERM)||(f&IFP_END))
				fputc('\n',file);
		}
		else 
		{
			if(f&IFD_STRING) // never reached, yet
			{
				if(optVerbose)
					printf("%s\n",temp);
	
				// ASSERT(d<nextFreeString); // nextFreeString isn't changed nemore after loadLines finishes, so it represents the number of strings found
				sprintf(line,"%08X-%08X\t'%s'\n",(i<<2)+loadAddress, (strlen(strings[d])+(i<<2))+loadAddress, strings[d]);
				fputs(line,file);
				i+=(strlen(strings[d])+strlen(strings[d])%4)>>2; // must be on word boundary				
			}
			else
			{
				word2String(d,temp);
				sprintf(line,"%08X\t%08X\t%s\n",(i<<2)+loadAddress, d, temp);
				fputs(line,file);
			}
		}
	}

	crossRef.printAllRefs(file);
	fclose(file);
}

// THIS FUNCTION NEEDS 'SOME' WORK... (if this would work better, you'd get much better output)
word CPsxExe::extractASCIIZStr(word start, word end, char* buffer) // assumes strings start(and end) on word boundaries
{
	ubyte j=0;
	char c;
	word i;

	for(i=start;i<end;i++)
	{
		for(ubyte cc=0;cc<4;cc++)
		{
			c=*(((char*)&(lines[i].instruction))+cc);
			
			if( lines[i].instruction==0 || (c==0&&!isValidAddress(lines[i].instruction)) || (c==0&&cc!=0)) // lame hack
			{
				if(j<2)
					return -1;

				buffer[j]=0;
				lines[i].flag=IF_DATA|IFD_STRING;
				return i;
			}

			// printable: !"#$%&'()*+-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[+]^_`abcdefghijklmnopqrstuvwxyz{|}~
			if(!isprint(c) && !(c=='\n'||c=='\r'||c=='\t') )
			{
				if(i>start)  // don't keep repeating on the same string
				{
					buffer[j++]=0;
					return i-1;
				}

				return -1;
			}

			if(c=='\n')
			{
				buffer[j]='\\';
				j++;
				buffer[j]='n';
				j++;
			}
			else if(c=='\t')
			{
				buffer[j]='\\';
				j++;
				buffer[j]='t';
				j++;
			}
			else if(c=='\r')
			{
				buffer[j]='\\';
				j++;
				buffer[j]='r';
				j++;
			}
			else 
			{
				buffer[j]=c;
				j++;
			}
		}
		
		lines[i].flag=IF_DATA|IFD_STRING;
	}

	return i;
}

bool isValidAddress(word addr)
{
	if((addr>>28==0||addr>>28==0xA||addr>>28==0x8)&&((addr&0x00ffffff)<0x001fffff))
		return true;
	if(addr>0xbfbfffff&&addr<0xbfc80000)
		return true;
	if(addr>=0x1f000000&&addr<0x1f00ffff)
		return true;
	if(addr>=0x1f801000&&addr<0x1f801fff)
		return true;
	
	return false;
}

void word2String(word d, char* s, char alt)
{
	if(s==NULL)
		throw "GRRR! don't feed me null pointers!! I'm on a no-null-pointer diet!";

	char* p=(char*)&d;
	char c=alt;

	for(int i=0;i<4;i++)
	{
		c=*(p+i);
		if(isprint(c))
			*(s+i)=c;
		else
			*(s+i)=alt;
	}
	
	s[4]=0;
}


bool CPsxExe::isValidInstruction(word d, word pc)
{
	if(d==0)
		return true;
		
	char op=DECODE_OP(d);
	
	if(op==opSpecial)
	{
		return (strcmp(RTypeMnem[DECODE_FUNC(d)],"**")!=0);
	}
	else if(op==opRegImm)
	{
		return (strcmp(RITypeMnem[DECODE_RT(d)],"**")!=0);
	}
	else
	{
		switch(op)
		{
		case opCop0:
			if(DECODE_RS(d)>32)
				return false;
			return (strcmp(SysCoMnem[DECODE_RS(d)],"**")!=0);
		case opCop1:
			return false;
		case opCop2:
			if(DECODE_RS(d)>32)
				return false;
			return (strcmp(GTEMnem[DECODE_RS(d)],"**")!=0);
		case opJ:
		case opJAl:
			if(!isValidAddress(DECODE_INDEX(d,pc)))
				return false;
			return true;
		default:
			return (strcmp(ITypeMnem[op],"**")!=0);
		}
	}

	return false;
}



void CCrossRefTbl::addRef(word target, word src)
{
}

void CCrossRefTbl::printAllRefs(FILE* f)
{
}


void CSymbolTbl::addSym(word val, string name, ubyte type) // don't distinguish types, yet...
{
 symbols.insert(SYMTBL::value_type(val,name));
}

bool CSymbolTbl::lookup(word val, string& name)
{
	SYMTBL::iterator it = symbols.find(val);
 
	if(it != symbols.end())
	{
  name=(string) (*it).second;
		return true;
	}
	
	return false;
}


void CSymbolTbl::markCode(CPsxExe* exe)
{
	if(!inited)
		return;

	word addr;

	SYMTBL::iterator it=symbols.begin();

	for (it++;it != symbols.end(); it++) // symbols.begin() is invalid, so inc to begin with... (?) POSSIBLE BUG
	{
		addr=(word) (*it).first;
		exe->lines[(addr-exe->loadAddress)>>2].flag|=IF_CODE|IFC_PROC|IFP_BEGIN; // should check if it's a code symbol... for now only code syms are added anyway... 
	}
}

void CSymbolTbl::load(FILE* f)
{
	char buff[256];
 char type;
	word d;
	char name[80];

	do
	{
		fgets(buff,255,f);
		
		if(buff[0]==';')
			continue;
		
		sscanf(buff,"%c,%x,%s",&type,&d,name);
		
		if(type=='P')
		{
			addSym(d,name,ST_PROC_EP);
		}
		else if(type=='L')
		{
			addSym(d,name,ST_LABEL);
		}

	}while(feof(f)==0);

	inited=true;
}

void CSymbolTbl::psyLoad(FILE* f)
{
	word addr;
	ubyte flag;
	ubyte length;
	word xflag;

	char name[256];

	do
	{
		if(fread(&addr, 4, 1, f)!=1)
			break;
		
		if(fread(&flag, 1, 1, f)!=1)
			break;
		
		switch(flag)
		{
		case 2: // addr|f|l|sym[l]
			if(fread(&length, 1, 1, f)!=1)
				break;
			
			if(fread(&name, 1, length, f)!=length)
				break;		
			
			name[length]=0; 

			if(CPsxExe::optVerbose)
				printf("0x%08x: %s (%i, %i)\n", addr, name, flag, length);

			addSym(addr,name,ST_PROC_EP);
		case 0x80: // addr|f
//			printf("flag=0x80; addr=0x%08x\n",addr);
			break;
		case 0x82: // addr|f|x
			if(fread(&xflag, 1, 1, f)!=1) // dunno what this byte means, seems like a flag for this address
			 break;
			printf("flag=0x80; addr=0x%08x; extra=0x%02x\n",addr,xflag);
			break;
		case 0x88: // addr|f|xxxx|l|string[wlen]
			if(fread(&xflag, 4, 1, f)!=1) // dunno what this word means, seems like an eXtra flag for this address
			 break;
			if(fread(&length, 1, 1, f)!=1) // length 
			 break;

			if(fread(&name, 1, length, f)!=length)
				break;		
			
			name[length]=0; 

			printf("flag=0x88; addr=0x%08x; extra=0x%02x; len=0x%08x; string: %s \n",addr,xflag, length, name);
			break;
		case 0x8a:
			handlePsySym8a(f);
			break;
		default:
			printf("!!!!!!d'oh, unknown flag at: %x\n\n", ftell(f)); // there are still a lot left..
		}
	}while(feof(f)==0);

	inited=true;
}

void CSymbolTbl::handlePsySym8a(FILE* f)
{
	ubyte flag;
	ubyte length;
	ubyte xflag;
	word dummy;
 char name[255];
	
	do
	{
		if(fread(&dummy, 4, 1, f)!=1) // ?
			break;
		
		if(fread(&xflag, 1, 1, f)!=1) // length 
			break;

		if(fread(&name, 1, length, f)!=length)
			break;		
		
		name[length]=0; 

		printf("extra=0x%02x; len=0x%08x; string: %s \n",xflag, length, name);
	}while(feof(f)==0);
}

void CPsxExe::decodeInstruction(word d, word pc)
{
	if(d==0)
	{
		strcpy(disasmtemp,"nop");
		return;
	}

	strcpy(disasmtemp,"Opcode unknown!");
	
	char op=DECODE_OP(d);

	if(!isValidInstruction(d, pc))
		return;
			
	if(op==opSpecial)
	{
		char func=DECODE_FUNC(d);
		
		switch(func)
		{
		case spJR:
		case spJAlR:
			sprintf(disasmtemp,"%-7s%s %s",RTypeMnem[func],CPURegStr[DECODE_RS(d)],DECODE_RD(d)>0 ? CPURegStr[DECODE_RD(d)]:"");
			break;
		case spSll:	// no rs, but sa
		case spSrl:
		case spSra:
			sprintf(disasmtemp,"%-7s%s, %s, 0x%02x",RTypeMnem[func],CPURegStr[DECODE_RD(d)],CPURegStr[DECODE_RT(d)],DECODE_SA(d));
			break;
		case spMfHI: // only rd
		case spMfLO:
			sprintf(disasmtemp,"%-7s%s",RTypeMnem[func],CPURegStr[DECODE_RD(d)]);
			break;
		case spMtHI:	// only rs
		case spMtLO:	
			sprintf(disasmtemp,"%-7s%s",RTypeMnem[func],CPURegStr[DECODE_RS(d)]);
			break;
		case spMult:	// no rd
		case spMultU: 
		case spDiv:
		case spDivU:
			sprintf(disasmtemp,"%-7s%s, %s",RTypeMnem[func],CPURegStr[DECODE_RS(d)],CPURegStr[DECODE_RT(d)]);
			break;
		case spSysCall:
		case spBreak:
			sprintf(disasmtemp,"%-7s 0x%05x",RTypeMnem[func],DECODE_COPFUN(d));
			break;
		case spSllV:
		case spSrlV:
		case spSraV:
			sprintf(disasmtemp,"%-7s%s, %s, %s",RTypeMnem[func],CPURegStr[DECODE_RD(d)],CPURegStr[DECODE_RT(d)],CPURegStr[DECODE_RS(d)]);
			break;
		default:
			sprintf(disasmtemp,"%-7s%s, %s, %s",RTypeMnem[func],CPURegStr[DECODE_RD(d)],CPURegStr[DECODE_RS(d)],CPURegStr[DECODE_RT(d)]);
		}
	}
	else if(op==opRegImm)
	{
		sprintf(disasmtemp,"%-7s%s, 0x%x",RITypeMnem[DECODE_RT(d)],CPURegStr[DECODE_RS(d)],DECODE_OFFSET(d,pc));
	}
	else
	{
		if(op<opLB)
		{
			if(op>=opCop0)
			{
				switch(op-opCop0)
				{
				case 0:
					if(strcmp(SysCoMnem[DECODE_RS(d)],"**")==0)
						sprintf(disasmtemp,"System Coprocessor opcode 0x%02x unknown! (0x%08x)",DECODE_RS(d),d);
					else
					{
						sprintf(disasmtemp,"%s\t%s,%s",SysCoMnem[DECODE_RS(d)],CPURegStr[DECODE_RT(d)],SysCoRegStr[DECODE_RD(d)],DECODE_COPFUN(d));
					}
					break;
				case 1:
					sprintf(disasmtemp,"!! Accessing unknown coprocessor?");
					break;
				case 2:
					if(strcmp(GTEMnem[DECODE_RS(d)],"**")==0)
						sprintf(disasmtemp,"GTE opcode 0x%02x unknown! (0x%08x)",DECODE_RS(d),d);
					else
					{
						if(DECODE_RS(d)==copCfC||DECODE_RS(d)==copCtC)
						{
							sprintf(disasmtemp,"%-7s%s,%s",GTEMnem[DECODE_RS(d)],CPURegStr[DECODE_RT(d)],GTERegStr2[DECODE_RD(d)],DECODE_COPFUN(d));
						}
						else
							sprintf(disasmtemp,"%-7s%s,%s",GTEMnem[DECODE_RS(d)],CPURegStr[DECODE_RT(d)],GTERegStr[DECODE_RD(d)],DECODE_COPFUN(d));
					}
					break;
				default:
					sprintf(disasmtemp,"!! Accessing unknown coprocessor?");
				}
			}
			else
			{
				switch(op)
				{
				case opJ:
				case opJAl:
					sprintf(disasmtemp,"%-7s0x%x",op==opJ ? "j":"jal",DECODE_INDEX(d,pc));
				break;
				case opLUI:
					sprintf(disasmtemp,"%-7s%s, 0x%04x",ITypeMnem[op],CPURegStr[DECODE_RT(d)],(unsigned short)DECODE_IMMED(d));
					break;
				case opBlez: // no rt
				case opBgtz: // no rt
					sprintf(disasmtemp,"%-7s%s, 0x%x",ITypeMnem[op],CPURegStr[DECODE_RS(d)],DECODE_OFFSET(d,pc)); 
					break;
				case opBeq:
				case opBne:
					sprintf(disasmtemp,"%-7s%s, %s, 0x%x",ITypeMnem[op],CPURegStr[DECODE_RS(d)],CPURegStr[DECODE_RT(d)],DECODE_OFFSET(d,pc)); 
					break;
				case opAddI:
				case opAddIU:
				case opSltI:
				case opSltIU:
					sprintf(disasmtemp,"%-7s%s, %s, 0x%04x",ITypeMnem[op],CPURegStr[DECODE_RT(d)],CPURegStr[DECODE_RS(d)],(unsigned short)DECODE_IMMED(d));
					if(DECODE_IMMED(d)<0)
					{
						sprintf(disasmtemp2," ;(=-0x%x)",-DECODE_IMMED(d));
						strcat(disasmtemp,disasmtemp2);
					}
					break;
				default:
					sprintf(disasmtemp,"%-7s%s, %s, 0x%04x",ITypeMnem[op],CPURegStr[DECODE_RT(d)],CPURegStr[DECODE_RS(d)],(unsigned short)DECODE_IMMED(d));
				}	
			}
		}
		else // op>=opLB
		{
			sprintf(disasmtemp,"%-7s%s, 0x%04x(%s)",ITypeMnem[op],CPURegStr[DECODE_RT(d)],(unsigned short)DECODE_IMMED(d),CPURegStr[DECODE_RS(d)]);
		}
	}
}

void CPsxExe::disassemble(char *name)
{
	disassemble(name,loadAddress,loadAddress+codeLength);
}


void main(int argc, char* argv[])
{
	CPsxExe exe;

	try
	{
		printf("AdisasM ver 0.2b copyleft 1998 Antiloop -- adriaan@myself.com.\n");
		exe.doCmdLine(argc,argv);
	}
	catch(char* e)
	{
		printf("Exception: %s, aborting...\n",e);
	}
	catch(...)
	{
		printf("!!Unknown exception, aborting...\n");
	}
}




/* VERY OLD IDEA... left it in here.. maybe someone'll pick it up
ubyte CPsxExe::backTraceReg(word address, ubyte regspec, word& val, ubyte region)
{
	if(lines==NULL)
		throw "load the file into memory before trying to backtrace a register, dumbo!";

	btrr_regspec=regspec;
	btrr_end=address-region-loadAddress;

	if(btrr_end<0)
		throw "region invalid in backTraceReg";

	ubyte ret=backTraceRegRecurse(lines,address,regspec,btrr_val);

	val=btrr_val;
	
	return ret;
}

ubyte btrr_regspec;
word btrr_val;
word btrr_end;

#define BTRR_NOT_FOUND 0
#define BTRR_CONSTANT  1
#define BTRR_MEM_CONT  2

ubyte backTraceRegRecurse(CCodeLines* lines, word address)
{
 if(address>
}*/


